# Welcome and Liz Rice: A Beginner's Guide to eBPF

## A Beginner's Guide to eBPF
This is a technology that I've been really excited about for a few years now. And in fact, I joined the ice over going to get really immersed in ebpf because I so then it had been working in this space for such a long time both on the Kernel side and in the cilium project, which is Networking, for kubernetes and Beyond based on ebpf. 
Today. I'm going to talk about why I'm so excited about it, why I think it's really revolutionising what we can do in terms of tooling for not just networking but also observability and Security in the cloud native space.
I'm going to show you some code because I would think that helps to make things a bit more concrete and I I am also going to just talk a little bit more broadly about the kind of tools that we can build based on ebpf. 

## What is eBPF 
So to get started. I'm going to assume that people can see my slides. I'm hoping someone will tell me in chat if there's any issues, my preview looks slightly strange. But yes, so what is ebpf stands for extended Berkeley packet filter, which Tells you something about the history of this technology, but it's not terribly useful for understanding, what it really is. What it really is, is a way of making the kernel programmable. It lets us run custom programs inside the kernel. Brendan Greg, who's a real Pioneer. In this space has a couple of really useful quotes. I think the first is the ebpf brings superpowers to X. And I hope that, by the end of this presentation, you'll see what he means. And, and I believe this to the other quote here about ebpf. There's to the Linux kernel, what JavaScript does to HTML terms of allowing us to make it programmable. Change the way that the kernel behaves. 

## Run custom code in the kernel
So how do we actually do this? Most of us if we're writing applications, right in user space and every time we want to do anything that interacts with Hardware in any way, writing to a file, displaying something on the screen, talking over a network, anything at all. Pretty much requires, assistance from the kernel and the kernel is a sort of privileged part of the operating system, most of the time. If we're developers or operators, we don't really need to care. Very much about what's happening inside the kernel, we normally deal with what's happening in user space. With ebpf, though. We can start running custom code inside the kernel. We have ebpf programs. We load them into the kernel and we attach them to events. Now if we're in a user-space and the program is in the kernel, then there has to be something called a system call between those two things and the system called that relates to ebpf is called BPF. 

## man BPF
And the man page for BPF gives us lots of helpful information about what BP f is and what we can do with it, starting with the fact that I say ebpf or B PF pretty interchangeably. That's very Home. And they essentially these days mean pretty much the same thing the E stands for extended and over the years as ebpf has been developed. It was extended particularly to add some helper functions and the ability to share data between ebpf programs and user space and each other. And those two things are really what the the easy kind of implies. But for most of us, Doesn't really that doesn't really matter in the distinction doesn't really matter. So if I say BPF or ebpf, I mean the same thing. So we're going to write programs that are going to be loaded into the kernel and they can't harm the the running system because that would be a really bad thing. If we were to crash, the kernel will come back to that. Swim right? Ebpf programs. This is saying in. See, that is true for almost all BPF code, but actually more recently the rust, compiler has also supported compiling to ebpf bytecode. So we write our source code. It's compiled into machine readable ebpf bytecode. 

## bcc
Now we have to write that program that's going to run in the kernel and we also have to write the user space code or we need a user space application to load the program into the carnal and maybe interact with it. There are lots of different approaches to doing that various different libraries and supporting tools to help us with ebpf today. I'm going to use a framework called BCC which is Play the grandfather of all of these different BPF related Frameworks and it really does make it a lot easier to right BPF programs on the user space side. It gives us language support various different languages supported. I'm going to be using Python and it also takes care of compiling. The ebpf program for us and in interacting with the kernel using the BPF system call and another system calls. 

## eBPF Hello World
So what would a hello world look like? Well, this is kind of the Sea Side. The kernel side. Let me see if I can share my screen and we can actually write hello world live. Okay, so I hope that you can see an editor. Again. I'm going to assume someone will shout at me. If you can't see the editor. And what you should see here is a python file and there's a string here called program. I'm actually going to write my C code as a string here and I'm just going to write. Hello. It's going to take some context that for this example. I'm going to ignore. And all I'm going to do is say Trace out. Hello world. Cuz we do how long is the right place? I just need to return zero to say that all went. Well, that is going to be my BPF program that's going to run in the kernel and BCC makes compiling that program as simple as this line. Well I need to do now is attach it to an event and let's say that I want to attach it to, I'm going to use something called a kaypro. Okay? Probe is the entry to any function in the kernel. And I'm actually going to use the entry to a system called function, system call that I'm going to use is exactly exactly is run. Every time you run a new executable. I'm just going to find event equals, exactly. And come back to that when exactly is hit. I want to call the function. Hello. How do I get exactly? E. So, the actual sister function name varies from architecture to architecture, not fix. I should be get, I want to get the function name that's associated with exactly. But that tells you see see where to attach this program, what event to attach it to? And then all I need to do is Output. The tracing. Hopefully, that's my BP F program written both the user space side, the Python and the C code that I'm going to run. So let's try it out. Okay, and it actually showed some old tracing for when I run it before and then a whole bunch of new tracing happening. I'm using vs code remote. There's a lot going on on this virtual machine and that's why you can see this being triggered over and over again, if I take a different window on the same machine and just run PS2, see what's running. I can see, okay, process, ID, 1295 72, which is after scroll up to the top of the screen. So my bash shell. Run an executable and that caused that particular that. Well it cause the BPF program to be triggered. So, if we come back to the slides, we should see. Don't know if that's going to stop presenting or not. There we go. The thing that I'm trying to convey, there is really how we didn't just get the tracing information. We also got some contextual information about the event that triggered it. We could see the name of the executable. We could see the process ID. There's timestamps. There's a bunch of context that we can get from inside a BPF program. 

## eBPF Hello Packet
We can attach to lots of different types of events and a kind of equivalent on the network side would be too attached to a network interface and we could run some tracing. Whenever a network packet is received. And in that case, the context would be passed in actually has the content of the network packet itself. 

## Triggering eBPF programs
And we can trigger ebpf programs for from all sorts of different events. I showed you. Okay, probes, which is functions in the kernel itself. There's the equivalent for use of space. So, any function that you're running in any application, we can attach ebpf program to, we can also attach to the return from any function in both the kernel. Uses space. We can attach to trace points with can attach the network packets. We can attach to perform events for observability. We can pretty much attach our BPF programs to any kind of event. 

## bpf_trace_printk()
Now, my tracing wrote to, well, I read it out in Python, but I used kind of debugging helper function, that always wants tracing to the same location globally. And that's not terribly helpful. Certainly not in a production system. You might have many many different ebpf programs running and if they were all writing to the I'm Trace that that quickly becomes hard to hard to manage and hard to read. So instead we want to pass data between user space and kernel using what's called an ebpf map. 

## eBPF maps
So there are lots of different types of ebpf map. They're all key value stores and they allow us to write data in the kernel and read it out from user space or vice versa. 

## eBPF object file includes code & maps
So when we compile a BPF program, we actually get not just the object file for the bytecode, the program itself. We also get a definition of the maps that we want to load into the kernel. So there's an object file that we get out of the compiler user space uses BPF system call to both load the program into Kernel and load the maps or create the maps inside the kernel. The program gets passed through a verification step. And this is really important in terms of making sure that the BPF code is safe to run. As I mentioned before, it must not crash. If it crashes, it brings down your machine because it's in the kernel. So in order to ensure that it's safe to run, the verifier will check certain restrictions on the code and we'll talk in a moment about what those restrictions are. So the program gets loaded, the maps are created in the kernel. Then use a space needs to tell the kernel what events are going to trigger this kernel. You saw me attached to The entry point to a system call, and then if we have Maps involved, we can use some other operations in that vpf, system call to read and write information into any Maps. 

## Maps using
and BCC actually makes it incredibly easy to use these Maps. I'm gonna just go back to screen sharing again for a minute and we can take a little go at sending some data using a map. Again, I hope you're going to be able to see my my program, this time. I'm actually going to attach to a network interface and I'm going to next EP and the so we're going to look at Network packets arriving and I'm going to count them. So I'm not going to be attaching to a system call anymore, and I'm not going to be attaching to a k program anymore. I am going to be attaching to something called XDP which stands for Express data path, and it's a way of hooking BPF programs into a network interface and we're going to hook into the ethernet 0 interface and I have to do this in a slightly different way from before but this is kind of characteristic of ebpf. Some. Some things are not quite as consistent across different types of BPF program, or different types of event, but hopefully, this gives you an idea. So, we need to lay the function. I think this needs to be free got load function. Hello. And I'm going to change this function now so that it doesn't just Trace out. Hello world. I'm gonna have a Very simple, hash table. I'm going to call it packets. You see makes this very straightforward. and, This hash table is well. It's so key Value Store. Sigh need a key. I am for the purposes of this example. Always going to use a key of zero. I'm going to store a counter against that key, which I'm going to initialize to zero. I need a pointer. Hi, whenever a network packet arrives, it's going to trigger this function to be run. And what I want to do is look up the current value of the counter in the key Value Store increment, it and store it back again, so I'm going to look up. What the current value is for Mikey? And if this is the first time through there isn't going to be a value yet in which case, I would get nil for my 40 for my pointer. So, and I say if it's not zero. Friends going to set the counter to the current value. Otherwise, it'll be initialized to 0. I'm going to increment it and then I'm going to update the value. So, that should be. Forward. All I should need to do now is have something to print this out. I'm going to do this in a loop. And every second. So I'm going to sleep for a second and then I'm going to print out the key value in its data structure items in it. You print. Key, and you just call that counter. I'll counter correctly. That would be better. and that with, I mean, fiegel value. Okay. Hope that's going to be everything I need to do to count. A packets. Now, I'm attaching to the F0 interface, which has the IP address on 72. 17.0 to. So first of all, let me check that run this program. Oh, I need to tell it that this is actually a XDP program. Okay, and if I start pinging this address? Okay, we start seeing well, I've failed to put a space in there. But hopefully you get the idea what we're seeing is packets arriving, but then actually getting lost on the pink side and that's because for a BP F program. If I return 0, well, the return code tells the kernel what to do with a packet and 0 actually tells the kernel to throw the packet away. So I need to modify this and say actually carry on past that Network packet up the stack as you would have done. Having a space here as well. Make this a bit neater. Oh, now that I'm passing it through. If I reload the program, we should start seeing pings getting passed successfully. So my counter is incrementing with every ping packet and they are now being responded to as expected. So not only have we shown with that. How we can pass information from the kernel to use a space. We've also shown that we can pretty easily. Lee start manipulating on doing things with network packets, we could actually change things in that Network packet if we so choose. So if I managed to stop the sharing again and come back to the slides and we've seen some helper functions that you've seen me. 

## eBPF helper functions
Use it for tracing. We can also get information about the context of the event. We might be able to get things like the current time or the process ID information that might be useful to pass. For observability or security purposes from the ebpf program. 

## Verifier
I also briefly mentioned, the verifier. And how does it ensure that the program is safe to run? Well, one of the things it ensures is that you must check that a pointer is not null. Before you dereference it. It will check for memory access to make sure it's in a safe range. So, whenever you look at Network packets, you're required to check that the memory. You're going to look at is within that Network packet before you look at it. And you're also essentially not allowed to have loops you. There are some kind of programming tools that you can or programming tricks that you can use to, to have small Loops. But in order to make sure, there are no infinite Loops essentially the verify objects to any loops. Also has to make sure that it's always going to exit. So that's my kind of concrete examples of BPF programs that I've used. I see a question coming in to say what tools used to write and execute the python. So if the question is, what the idea is that I'm using there, that was Visual Studio code and it's just using a regular python, you know, python runtime standard

## Dynamically change kernel kehavior
Okay, so we've seen We can write these ppf programs, and I've told you that we can dynamically change the way that the kernel behaves. What's the impact of that? Why is this so important? Well, part of it is the speed with which we can get changes into the kernel. If you want to change the Upstream kernel. It's a big deal, you know, you have to convince the kernel community that it's a good idea. And then that change gets made in the Upstream kernel. It's still then can take years before it actually gets to The distribution is that we're using in production systems. This incidentally is one of the reasons why ebpf is kind of suddenly. So exciting. We've reached a point where pretty much every distribution that people are using in production now supports a sufficient level of ebpf support features in the carnal to be really useful. So with BPF, instead of waiting for changes to be made in the kernel upstream and then through the distro. Well, we can just write ppf programs and load them. Literally. Dynamically. You've just seen me do it. So not only do you just have to write the code and run it you don't even have to reboot your machine. You can install moment programs that are already running. One really nice example of this being used is packet of death mitigation. So packet of death is where there's a vulnerability in the kernel, and some kind of carefully crafted Network packet can be sent to the machine. The kernel doesn't handle it correctly, and crashes. 

## Packet of Death
So I think I have an illustration of that. Yeah. So the idea is that that packet of death, there should be a little explosion hasn't come through. Nevermind. Anyways, crashes the kernel when this packet, arrives with BPF rather than having to wait for a patch and apply a patch, which requires rebooting machines. And so on, we can just have a dynamic loaded vpf program that can check every packet as it arrives at the network interface just like I did in my example, but looking for that. Specifically crafted packet of death. And if it is one, just discard it. We can mitigate that kernel, vulnerability, live, and dynamically. 

## Programmable kernel in kubernetes deployments
What is this mean for kubernetes deployment in the world of cloud native? And what does it mean for tooling that can take advantage of ebpf? Well, in kubernetes, we're running our code, our application code in containers and those containers are running or grouped inside pods, but all of the pods on any given host. Whether they're running on bare metal, or on a virtual machine, they all share one kernel. So whenever your application code running in containers wants to do anything, like, send and receive Network packets or access files or whenever kubernetes wants to create new containers. Anything kind of interesting is going to require assistance from the kernel and that means the kernel knows about That's happening on that machine. And that means that if we instrument the kernel with ebpf programs, we can be aware of things that are happening in any pod and we can do that without needing to change the applications. We don't even need to reconfigure them. We immediately have visibility and potentially control using ebpf. F. This is a really nice contrast to the side car model that typically gets used for instrumenting, whether we're talking about observability or security tooling a lot of it and service mashes. Well, a lot of them are use the sidecar model Nathan Leclair. Did this really great cartoon, I think explaining how the future of sidecars is actually the kernel. So what do we mean by this? 

## a sidecar has a view across one pod
Well, a sidecar model has every pod instrumented, using an extra sidecar container. So when you want your pod to be instrumented whether this is fair observability for logging for tracing for service mesh for security that tool has to be injected as a sidecar into each pod, so that the sidecar has visibility over what's happening. In that pod and the site car gets there by being defined as yeah. Mille. And something has to create that Gamal. You probably aren't doing it. Manually. It's probably happening as part of maybe CI, CD, or an admission control. Webhook. Something is configuring that llamo and what if it goes wrong or what if you don't label your app such that it does get this. Yeah, Mille added correctly. If there's no llamo, there's no sidecar and your application just doesn't get instrumented. In contrast with ebpf where because we can add the instrumentation directly into the kernel. The pod doesn't need any changes at all to be observable to be subject to whatever the ebpf code can do. That also means, not only do you not have to modify any configuration for your apps? If you are in a situation where your Node gets compromised in any way or the attacker. Probably won't insert instrumentation for you. But any process running on that host is subject to the same. It's just as visible to ebpf as a legitimate program. So it makes malicious activity is just as as as visible to ebpf as expected activity. 

## Efficient container networking
BPF also gives us really efficient container networking. So in a normal traditional environment without BPF, there's a network name space for every pod. And that means it has its own networking stack. There's also a networking stack on the host. So when a packet arrives at the interface to the host, if it's destined for the Pod, it has to Traverse all the way through the host. Networking stack to reach the virtual, ethernet connection, to the Pod and then Traverse another networking stack. With ebpf particularly with a cni that's based on ebpf like cilium. Well cilium has set up the endpoints. It knows what pods are on this host. It knows about the addressing for the pods. So when that packet arrives at the hosts network interface, cilium can pick that pack it up, and send it directly to the Pod where its intended to arrive, and bypass that whole networking stack on the host. And that leads to real. 

## TCP RR - higher is better
Measurable improvements in this chart, the two middle bars. The the yellow and green ones are cilium and Calico running in traditional non ebpf mode and the red and orange bars are using ebpf. We get much better request response rate with ebpf mode nearly as fast as if we weren't involving containers at all, which is what the blue node to node for assuring. There are lots of different ways of measuring Network performance. So I'd encourage you to go and check out that Benchmark blog post, that's referenced at the bottom here. If you're interested in seeing other ways that we were able to measure Network performance, but the bottom line is be F, makes things more efficient. 

## Efficient kubernetes-aware networking
But it's not just efficient. It's also aware of kubernetes identities and information like services and other labels. So because cilium is setting up endpoints and it's aware of things like the the pot identities and the service identities. We can both drill into the detailed Network flows and show you details of every message that flows and we can zoom out and see how different services are connected, whether this is within one cluster or across multiple clusters. 

## eBPF-accelerated service mesh
This to next step for this evolution is using ebpf as the data plane for service mesh. So in a sidecar enabled, service mesh in a traditional networking environment, not only does the packet have to go through the hosts networking stack. When it gets to the Pod. It has to Traverse through the kernel to use a space to get to the Proxy. And then back through the caramel again to get to the application container with a BPF, we can do the same kind of shortcutting that I showed you for just normal container networking. And again, this is going to make a substantial Improvement to latency, which is one of the concerns that's often cited about service Nash because we can just be much more efficient about getting those Network packet. Through the proxy and to the application. So that's really a kind of lightning tour around some of the reasons why I think that the new generation of tooling that's based on ebpf is so much more effective so much easier to deploy really efficient. We didn't really even touch on some of the security observability that we're able to achieve. With ebpf again because B PF can have visibility into everything that happens. Making Intelligent Decisions about what's malicious, is a real superpower from ebpf tooling. I hope that's given you some idea why I'm so excited about this space and this technology ebpf .i O is a great site if you want to dig into the details, And you can always find me online. 

## Thank you
That there's rice is also my GitHub repo while you'll find my sample code, if you want to dig into it. So, yeah, thank you very much and I hope you are even a tiny bit as excited about ebpf as I am. But thank you so much Liz. 


We had a question that came in during a presentation from AP. So said, you know, safeguarding is crashes of your ebpf program is fine to the, make sure that you can't bring the kernel down, but are there security risks in allowing custom code to be run in kernel? 
Yeah, it's a really great question. And I think the key thing is to think about the, the set of people who should be allowed to manipulate ebpf tooling. They're the same people who should be allowed to install a new kernel, you know, that that is a seriously privileged operation. Now, there is a thing called unprivileged vpf and cutting a long story short. I think the Now, is that unprivileged ebpf was pretty much a mistake and should be turned off. Not all distros today. Have unprivileged ebpf disabled. So I would recommend turning that Knob Off on your kernel. Even if you're not using BPF, it's a bad idea to allow unprivileged ebpf. 

I guess, one of those things which is also once you get to the point of allowing someone to install their own logo, custom code on your kernel to the extent. All bets are off. Anyway, that you shouldn't be allowing arbitrary code to kind of like it's bad enough grabbing a nun, you know a Docker image that you got from Docker Hub on your, you know, your kubernetes cluster. Let alone running at the kernel that you've kind of Eagle, you inviting somebody into the inner sanctum at that point. There's, there's going to be controls, I guess in place in terms of your point, Who's allowed to run things in there in the first place? 
With that in mind, I mean same goes for very privileged containers as well. Like, you know privileged allowing anyone to run privileged containers is giving them the keys to the kingdom. So yeah, keep that very risky. If only if only somebody had some kind of book about container security that people could read to learn more about this topic, which I can see just behind your head there in one way or the other. Yes, you can see behind me. 

Kind of with that in mind, though, talking about who's allowed to do these things. I mean, who do you see as being the prime audience for building things on top of ebpf? Is it something that you think developers are going to do? Is it something serious happens going to do? Or is it really going to be the purview of people building the tools and technologies that developers of operators people might use?
Yeah, it does, rapidly get pretty complex. And when you're working in the kernel, you're dealing with kernel constructs. So although I kind of encourage anybody who's interested. If they want to play with vpf programming. Don't be scared to give it a try because I think experimenting with things is fun. But for real production level tooling, you know, you probably not going To roll it yourself. You're probably going to be using tools that other people are working on. I mean, obviously, silly and being one of those, but I'd also mention Falco and pixie that are other ebpf based tools in the CN CF world. Yeah. It's this also, you know, when you start getting into this space you get to fight with the verifier about what's allowed and what isn't allowed. So it's a whole, there's a whole can of worms. 

Are you should also let mentioned about this idea of kind of. Well, we can just do it. Fits you almost like an end run around the whole site, a service major problem. At least a almost a new model for how we could Implement things like service meshes kind of one of the benefits of service Mitch's house is to an extent. They sort of build upon kubernetes is native abstractions, you know, we get a sense a little bit of out-of-the-box observability because we can hook into the kubernetes API so we can hook into Will those things if we start running things in the ebpf world though? Are we going to have to build new abstractions to build a new set of tools off or because give it is a we're building. This is massive ecosystem of stuff that sits on top of kubernetes, right? As the core of that kind of core set of abstractions. If these things now, get deployed as ebpf, do we need a new set of abstractions for these things to work?
I think, hopefully not. I think the real gains from ebpf in the service. Mesh. Well, do to be made in the data plane and we already have, you know, a variety of different but nonetheless, sort of, you know, a set of control plane abstractions for defining what service meshes are supposed to do. I don't think there's any reason why the data plane implementation of that can't be compatible with. You know, anything, we just need to do the work to plug different service mesh control planes, into that data plane. 

Gotcha, I guess by extension. And I was thinking about it from observability point of view. There's no reason why I guess I did ebpf program. Couldn't make use of say open Telemetry. So then if you've got already, Suites of products that are making use of that Oak working, you've got open to them, actually, collect a writing somewhere. You can only be PDF program that talks open Telemetry to that collector. So your can reuse already existing abstractions to do so. See things? 
Absolutely. That's something. We've been working on in cilium to make some of this data available in open Telemetry form. And yeah, it's absolutely true. And in fact, also, when we think about service mesh observability to get that kind of layer 7 observability, we would need a proxy anyway, so it's already going to an Envoy or maybe a link at the proxy to do that kind of layer 7 Parts, but it's more about making sure that we can get to that proxy and get to the application. Without having to Traverse whole network stacks. Because we can hook in at the summit. They are as well as a view interface layer. 

So your lot more choices about where you engage, whereas, with, when you're working the service. Well often when you working in that sort of more kubernetes native world, you have more restrictions placed upon you about where you can engage, because you've sort of hidden ways, you get choices with the ebpf layer. I've got a question here from actually from DP. Maybe one last question before we wrap up, this is from d.p. So thanks for question, DP. And DP asks, is this also the future of cybersecurity? I see this combined. It's aii that might allow the new levels of cyber security, you know, in terms of on getting this low-level raw data. Can we have more smarts intelligence in terms of protecting our applications? 
Yeah, absolutely something that I didn't really have time to show today was how you know, I showed Network flow and how we can get visibility into a given Network packet. But we also have that information about the process and we have information about the application that was running at the time and we have information about the container that it was in and the kubernetes. But so actually we have this full context. Say well, this network connection to a cryptocurrency mining pool. For example, not only did it happen and when but also exactly what executable in what pod in what namespace on, What node running, what executable, there's a whole chain of information that we can get but we can use to identify malicious behavior and I think going forward we're going to see See more intelligence applied. So for example, almost containers, if they're going to create a network connection do that pretty early on, in their life cycle or they always connect to the same place. But if a compromised container connects to some kind of dodgy command and control center, that might happen hours or days after the container was created and that probably is a red flag that could signal. You know something, unexpected is happening here. Yeah, so it's the future and find security. I think the answer is in my mind. It's a very powerful tool for getting a lot of really helpful information for detecting malicious. 

Oh, and just one last selfish question for me, is having struggled with this sort of stuff before, looking at the Linux security modules, like, selinux and gr. Security, and all of these things that we would have to do the disease ebpf, basically. - give us a much better way of implementing. Those kind of could process based controls that we would use then and putting it putting those things in the power of better. Programming languages. If nothing else in the better execution model for those kinds of protections?
Yeah, and also more flexibility. So there's a thing called BPF LSM relatively new kernel support required for it and it's still that there's more work going on, but essentially all those Linux security modules, selinux, a farmer. What have you? They're all hooking into an API and LSM API within the kernel BPF LSM. The idea is to use those same hooks. But instead of having a very fixed model for how the enforcement looks it can be customized and maybe it's bespoke, you know, it could be bespoke ebpf programs or it could be it gives us more flexibility in how we Can do things like selinux, but perhaps in a more easily managed way. 

Oh, we can hope this. Thank you so much. Thank you so much indeed for your help. There's a Great Links. Please do go check, do go check out the work that I serve and in doing. So I've got some really awesome products. I've also put a link to this book contains security into the attendee chat. So if you don't know more about that, you can go read the book and that link takes all of you to your O'Reilly subscriptions. You can read lizards book at your leisure. Let's thanks, once again for being part of the event today and maybe we'll get to share a day. Dangerous and buttock. Clenching least scary taxi ride again in the future. I think we should cut to the chase, miss out the taxi ride, and just have the post, taxi ride, beverage, you know, but I think we can do that. Maybe, I'll see you in hungry next year. Alright. Alright, so much for having me. It's a pleasure. You're welcome. Thank you so much, Liz.